#!/usr/bin/python3
#
#directory tree flattener
#unpacks archives and removes unnecessary subdirectory levels
#designed for handling large filesystems
#
#(c) 2013 Michael En√ülin	<michael@ensslin.cc>
#
#gplv3 or higher, no warranty, blah, blubb

import util
import argparse
import os
import subprocess
import shutil

parser = argparse.ArgumentParser(description="Flatten directory structure")
parser.add_argument("--no-unpack", action="store_true", default=False, help="If set, no archive unpacking will be performed")
parser.add_argument("--no-flatten", action="store_true", default=False, help="If set, no flattening will be performed")
parser.add_argument("--remove-empty-dirs", action="store_true", default=False, help="If set, empty directories will be removed during flattening")
parser.add_argument("--always", action="store_true", default=False, help="If set, all actions are performed without confirmation")
parser.add_argument("--default-yes", action="store_true", default=False, help="If set, the default option is 'Yes' instead of 'No' in confirmation dialogs")
parser.add_argument("--follow-symlinks", action="store_true", default=False, help="If set, symlinks will be resolved")
parser.add_argument("--traverse-mount-points", action="store_true", default=False, help="If set, subdirectories will be handled even if from a different filesystem")
parser.add_argument("--depth", type=int, default=-1, help="Search depth")
parser.add_argument("rootdir", default='.', nargs='?', help="The root directory")
args = parser.parse_args()

#check the root directory
rootdir = os.path.normpath(args.rootdir)
if not os.path.isdir(rootdir):
	util.fatal(rootdir + " is not a directory")
rootdir_mount_point = util.find_mount_point(rootdir)

def unpack_zip(archive, to):
	print("unzip -o -d'" + to + "' '" + archive + "'")
	return subprocess.call(['unzip', '-o', '-d' + to, '--', archive]) == 0

def test_zip(archive):
	print("unzip -t '" + archive + "'")
	return subprocess.call(['unzip', '-t', '--', archive]) == 0

def unpack_rar(archive, to):
	if not os.path.isdir(to):
		os.makedirs(to)

	print("unrar x -y '" + archive + "' '" + to + "'")
	return subprocess.call(['unrar', 'x', '-y', '--', archive, to]) == 0

def test_rar(archive):
	print("unrar t '" + archive + "'")
	return subprocess.call(['unrar', 't', '--', archive]) == 0

def unpack_tgz(archive, to):
	if not os.path.isdir(to):
		os.makedirs(to)

	print("tar xzv --file='" + archive + "' -C'" + to + "'")
	return subprocess.call(['tar', 'xzv', '--file=' + archive, '-C' + to]) == 0

def test_tgz(archive):
	print("tar tzv --file='" + archive + "'")
	return subprocess.call(['tar', 'tzv', '--file=' + archive]) == 0

def unpack_dir(path, parent, parententry):
	for entry in os.listdir(path):
		name = path + "/" + entry
		if not os.path.isfile(name):
			continue

		funcs = None
		lowername = name.lower()
		if lowername.endswith('.rar'):
			funcs = (unpack_rar, test_rar)
		elif lowername.endswith('.zip'):
			funcs = (unpack_zip, test_zip)
		elif lowername.endswith('.tar.gz') or lowername.endswith('.tgz'):
			funcs = (unpack_tgz, test_tgz)

		if funcs != None:
			to_path = path + '/' + util.find_free_name(path, os.path.splitext(entry)[0])
			question = lambda to_path: "unpack '" + path + '/' + util.colored(entry, 36) + "' to '" + util.colored(os.path.relpath(to_path, path), 36) + "/'"
			to_path_checker = lambda to_path: to_path == "" and "Path is empty" or os.path.exists(to_path) and "File exists: '" + to_path + "'" or True
			while True:
				util.confirm(question, default_answer = args.default_yes, path = path, val = to_path, valname = "target directory", valchecker = to_path_checker, valcompleter = util.filename_completer().completer, always_yes = args.always, testfun = lambda: funcs[1](path + '/' + entry))
				if to_path == False:
					break

				to_path = os.path.normpath(to_path)

				if not funcs[0](name, to_path):
					util.nonfatal("Could not unpack '" + name + "' to '" + to_path + "'")
					if args.always:
						break
					else:
						continue

				util.rm(name)

				break

def flatten_dir(path, parent, parententry):
	if parent == None or (args.traverse_mount_points and os.path.ismount(path)):
		return

	nameinparent = parent + "/" + parententry

	files = os.listdir(path)
	if len(files) == 0:
		if args.remove_empty_dirs:
			question = "Remove empty directory '" + path + "'"
			if util.confirm(question, default_answer = args.default_yes, path = parent, always_yes = args.always):
				util.rmdir(nameinparent)

	elif len(files) == 1:
		#move single entry of dir to parent dir, and delete dir
		if util.names_similar(files[0], parententry):
			#filename is similar to parent filename, do not concatenate
			newname = files[0]
		else:
			newname = parententry + " - " + files[0]

		#find a free new name for the file
		newname = parent + "/" + util.find_free_name(parent, newname, [parententry])

		while True:
			question = lambda newname: "Move '" + parent + "/" + util.colored(parententry + "/" + files[0], 36) + " to '" + util.colored(os.path.relpath(newname, parent), 36) + "'" 
			newname_checker = lambda newname: newname == "" and "Path is empty" or os.path.exists(newname) and os.path.normpath(newname) != parent + '/' + parententry and "File exists: '" + newname + "'" or True
			newname = util.confirm(question, default_answer = args.default_yes, path = path, val = newname, valname = "move to", valchecker = newname_checker, valcompleter = util.filename_completer().completer, always_yes = args.always)
			if newname == False:
				break
			newname = os.path.normpath(newname)

			#if newname is equal to the dirname, we need to rename the dir first ('mv a b', 'mv b/a a', 'rmdir b')
			if parent + '/' + parententry == newname:
				newparententry = util.find_free_name(parent, parententry)
				util.mv(parent + '/' + parententry, parent + '/' + newparententry)
				parententry = newparententry

			#check whether the file would be moved into a subdirectory of its old location
			if shutil._destinsrc(parent + '/' + parententry, newname):
				print("Can not move file to a subdirectory of its old location")

				if args.always:
					break
				else:
					continue

			#if the parent directory of newname does not exist yet, create it
			newdirname = os.path.dirname(newname)
			if not os.path.exists(newdirname):
				os.makedirs(newdirname)

			#move
			util.mv(parent + '/' + parententry + '/' + files[0], newname)
			util.rmdir(parent + '/' + parententry)

			break

if not args.no_unpack:
	util.walk(rootdir, None, None, unpack_dir, args.traverse_mount_points, args.follow_symlinks, args.depth)

if not args.no_flatten:
	util.walk(rootdir, None, None, flatten_dir, args.traverse_mount_points, args.follow_symlinks, args.depth)
